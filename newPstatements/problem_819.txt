You are given an m x n integer array grid where grid[i][j] could be:</h4> 1 representing the starting square. There is exactly one starting square. 2 representing the ending square. There is exactly one ending square. 0 representing empty squares we can walk over. -1 representing obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once. <br><h4>Example 1:</h4> <br><h4>Input:</h4> grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] <br><h4>Output:</h4> 2 <br><h4>Explanation:</h4> We have the following two paths:</h4> 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) <br><h4>Example 2:</h4> <br><h4>Input:</h4> grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]] <br><h4>Output:</h4> 4 <br><h4>Explanation:</h4> We have the following four paths:</h4> 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) <br><h4>Example 3:</h4> <br><h4>Input:</h4> grid = [[0,1],[2,0]] <br><h4>Output:</h4> 0 <br><h4>Explanation:</h4> There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid. <br><h4>Constraints:</h4> m == grid.length n == grid[i].length 1 <= m, n <= 20 1 <= m * n <= 20 -1 <= grid[i][j] <= 2 There is exactly one starting cell and one ending cell.