There are n piles of stones arranged in a row. The ith pile has stones[i] stones. A move consists of merging exactly k consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these k piles. Return the minimum cost to merge all piles of stones into one pile. If it is impossible, return -1. <br><h4>Example 1:</h4> <br><h4>Input:</h4> stones = [3,2,4,1], k = 2 <br><h4>Output:</h4> 20 <br><h4>Explanation:</h4> We start with [3, 2, 4, 1]. We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1]. We merge [4, 1] for a cost of 5, and we are left with [5, 5]. We merge [5, 5] for a cost of 10, and we are left with [10]. The total cost was 20, and this is the minimum possible. <br><h4>Example 2:</h4> <br><h4>Input:</h4> stones = [3,2,4,1], k = 3 <br><h4>Output:</h4> -1 <br><h4>Explanation:</h4> After any merge operation, there are 2 piles left, and we can't merge anymore. So the task is impossible. <br><h4>Example 3:</h4> <br><h4>Input:</h4> stones = [3,5,1,2,6], k = 3 <br><h4>Output:</h4> 25 <br><h4>Explanation:</h4> We start with [3, 5, 1, 2, 6]. We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6]. We merge [3, 8, 6] for a cost of 17, and we are left with [17]. The total cost was 25, and this is the minimum possible. <br><h4>Constraints:</h4> n == stones.length 1 <= n <= 30 1 <= stones[i] <= 100 2 <= k <= 30